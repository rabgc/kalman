#include <iostream>
#include <Eigen/Dense>  // Eigen library for matrix operations

# TODO Goal: Use M-PAGES Sinex class and process real SINEX data from MYCS3

/**
 * @class KalmanFilter
 * @brief Implements a Kalman Filter for state vector estimation for the case
 * when the state transition and design matrices remain constant over the 
 * experiment.  
 * 
 * The state vector can be multi-dimensional, and the state vectors can be 
 * stacked to mtrack ultile objects (stations, satellites, etc).
 *
 * The KalmanFilter lass provides methods for predicting and updating a state 
 * vector with an associated covariance matrix using a given state transition 
 * model.
 * 
 */
class KalmanFilter {
public:
     /**
      * @brief Constructor to initialize the Kalman Filter.
      * @param F state transition matrix.
      * @param H observation model matrix.
      * @param Q process noise covariance matrix.
      * @param R measurement noise covariance matrix.
      * @param P a priori covariance matrix.
      * @param x a priori state vector.
      */
    KalmanFilter(const Eigen::MatrixXd& F, const Eigen::MatrixXd& H,
                 const Eigen::MatrixXd& Q, const Eigen::MatrixXd& R,
                 const Eigen::MatrixXd& P, const Eigen::VectorXd& x)
        : // Member initializer list operator assigns vals (F) to member vars (F_)
        F_(F), H_(H), Q_(Q), R_(R), P_(P), x_(x) {  
        /* Arguments passed as const &. This means passing a reference and 
         * insures that the function will not modify the input paramters.
         * Constructor body contians these comments only.
         */ 
        }


    /**
     * @brief Perform prediction step of the Kalman filter.
     */
    void predict() {
        x_ = F_ * x_;                        // propagate the state
        P_ = F_ * P_ * F_.transpose() + Q_;  // propagate the covariance 
    }


    /**
     * @brief Update the state estimate using a new measurement.
     * @param z The measurement vector.
     */
    void update(const Eigen::VectorXd& z) {

        // Innovations 
        Eigen::VectorXd y = z - H_ * x_;   
        Eigen::MatrixXd S = H_ * P_ * H_.transpose() + R_; // innovations cov
        
        // Kalman gain 
        Eigen::MatrixXd K = P_ * H_.transpose() * S.ldlt().solve(Eigen::MatrixXd::Identity(S.rows(), S.cols()));

        // State update 
        x_ = x_ + K * y;    
        
        // The traditional covariance update can be unstable  
        // P_ = (Eigen::MatrixXd::Identity(P_.rows(), P_.cols()) - K * H_) * P_;  
        
        // So we use Joseph's stabilized update (cf. Bierman, 1977)
        Eigen::MatrixXd I = Eigen::MatrixXd::Identity(P_.rows(), P_.cols());
        P_ = (I - K * H_) * P_ * (I - K * H_).transpose() + K * R_ * K.transpose();
        
        // ensure positive definiteness preserved (cf. Bierman, 1977)
        P_ = (P_ + P_.transpose()) / 2.0;
    }


    /**
     * @brief Returns the current state estimate.
     * @return The state vector.
     */
    Eigen::VectorXd getState() const {
        return x_;
    }


    /**
     * @brief Returns the current covariance matrix.
     * @return The covariance matrix.
     */
    Eigen::MatrixXd getCovariance() const {
        return P_;
    }

    
private:
    Eigen::MatrixXd F_;  // state transition matrix
    Eigen::MatrixXd H_;  // observation model
    Eigen::MatrixXd Q_;  // process noise covariance
    Eigen::MatrixXd R_;  // measurement noise covariance
    Eigen::MatrixXd P_;  // state covariance
    Eigen::VectorXd x_;  // state estimate
};


// Example with 2 stacked 3-dim state vectors 
int main() {

    int num_vehicles = 2;
    int state_size = num_vehicles * 6;

    double dt = 1.0;

    Eigen::MatrixXd F = Eigen::MatrixXd::Identity(state_size, state_size);
    for (int i = 0; i < num_vehicles; i++) {
        int idx = i * 6;
        F(idx, idx + 3) = dt;
        F(idx + 1, idx + 4) = dt;
        F(idx + 2, idx + 5) = dt;
    }

    Eigen::MatrixXd H = Eigen::MatrixXd::Zero(num_vehicles * 3, state_size);
    for (int i = 0; i < num_vehicles; i++) {
        int idx = i * 6;
        H(i * 3, idx) = 1;
        H(i * 3 + 1, idx + 1) = 1;
        H(i * 3 + 2, idx + 2) = 1;
    }

    Eigen::MatrixXd Q = Eigen::MatrixXd::Identity(state_size, state_size) * 0.01;
    Eigen::MatrixXd R = Eigen::MatrixXd::Identity(num_vehicles * 3, num_vehicles * 3) * 0.1;
    Eigen::MatrixXd P = Eigen::MatrixXd::Identity(state_size, state_size);

    Eigen::VectorXd x = Eigen::VectorXd::Zero(state_size);

    KalmanFilter kf(F, H, Q, R, P, x);

    std::vector<Eigen::VectorXd> measurements = {
        (Eigen::VectorXd(num_vehicles * 3) << 1.0, 2.0, 3.0, 2.0, 4.0, 6.0).finished(),
        (Eigen::VectorXd(num_vehicles * 3) << 2.1, 3.9, 5.8, 3.9, 7.5, 11.1).finished(),
    };

    for (const auto& z : measurements) {
        kf.predict();
        kf.update(z);
        std::cout << "Updated State:\n" << kf.getState() << "\n";
    }
}


// // Single 3-dim state vector  
// int main() {

//     // Time step
//     double dt = 1.0;  

//     // State transition matrix (6x6 XV state in 3D)
//     Eigen::MatrixXd F = Eigen::MatrixXd::Identity(6, 6);
//     F(0, 3) = dt;  // x depends on vx
//     F(1, 4) = dt;  // y depends on vy
//     F(2, 5) = dt;  // z depends on vz

//     // Measurement model (we only observe position: x, y, z)
//     Eigen::MatrixXd H = Eigen::MatrixXd::Zero(3, 6);
//     H(0, 0) = 1;  // Observe x
//     H(1, 1) = 1;  // Observe y
//     H(2, 2) = 1;  // Observe z

//     // Process noise covariance 
//     Eigen::MatrixXd Q = Eigen::MatrixXd::Identity(6, 6) * 0.01;

//     // Measurement noise covariance (sensor noise)
//     Eigen::MatrixXd R = Eigen::MatrixXd::Identity(3, 3) * 0.1;

//     // A priori state (x, y, z, vx, vy, vz)
//     Eigen::VectorXd x(6);
//     x << 0, 0, 0, 0, 0, 0;  

//     // A priori covariance 
//     Eigen::MatrixXd P = Eigen::MatrixXd::Identity(6, 6);

//     // Create Kalman Filter instance
//     KalmanFilter kf(F, H, Q, R, P, x);

//     // simulated position measurements (x, y, z)
//     std::vector<Eigen::VectorXd> measurements = {
//         (Eigen::VectorXd(3) << 1.0, 2.0, 3.0).finished(),
//         (Eigen::VectorXd(3) << 2.1, 3.9, 5.8).finished(),
//         (Eigen::VectorXd(3) << 3.2, 6.1, 8.7).finished()
//     };

//     // filter the measurements 
//     for (const auto& z : measurements) {

//         kf.predict();

//         kf.update(z);

//         Eigen::VectorXd state = kf.getState();
//         std::cout << "Estimated Position: (" << state(0) << ", " << state(1) << ", " << state(2) << ") ";
//         std::cout << "Velocity: (" << state(3) << ", " << state(4) << ", " << state(5) << ")\n";
//     }

//     return 0;
// }


// simeple 1-dim XV state example
// int main() {

//     /* 
//     * Design a system  
//     */

//     // Define the system dynamics by a constant velocity model in 1D
//     double dt = 1.0;  // time step
//     Eigen::MatrixXd F(2, 2);  // state transition matrix 
//     F << 1, dt,
//          0,  1;

//     // Observation model observe position only 
//     Eigen::MatrixXd H(1, 2);
//     H << 1, 0; 

//     // Process covariance adds noise to both position and velocity
//     Eigen::MatrixXd Q(2, 2);
//     Q << 0.01, 0.005,
//          0.005, 0.01;

//     // Position measurement (sensor) noise 
//     Eigen::MatrixXd R(1, 1);
//     R << 0.1;

//     // A priori state and convariance 
//     Eigen::VectorXd x(2);
//     x << 0, 0;  
//     Eigen::MatrixXd P(2, 2);
//     P << 1, 0,
//          0, 1;

//     // Instantiate a Kalman Filter 
//     KalmanFilter kf(F, H, Q, R, P, x);

//     // Simulate measurements and store in a vector container 
//     std::vector<double> measurements = {1.0, 2.1, 2.9, 4.0, 5.1};

//     // Demonstration that vector containers are extendable like Python lists
//     measurements.push_back(6.3);  // append 6.3
//     measurements.push_back(7.5);  // append 7.5

//     // Deonstrates that vector containers can be "popped"
//     measurements.pop_back();  // removes the last element

//     // Lop over measurements 
//     for (double z : measurements) {

//         // Predict the next state
//         kf.predict();  
        
//         // Update with new measurement
//         kf.update(Eigen::VectorXd::Constant(1, z));  

//         // Print current state estimate
//         Eigen::VectorXd state = kf.getState();
//         std::cout << "Estimated Position: " << state(0) << ", Velocity: " << state(1) << std::endl;
    
//     }

//     return 0; // explicit return from main is best practice 
// }
